# アルゴリズム   
## スライドmax,min   
- 尺取りの感覚で累積max,minをとれる   
- 一定のサイズの区間（窓）で累積max, minを持っておける   
## 二分探索   
- `idx = bisect.bisect_left(list, num)`でnumが入り得る添え字の左端を得る   
- 答えで二分探索：まだ答えを小さくできるかどうかで二分探索   
- 二分探索は**単調性**が大事   
- しゃくとり法：条件を満たすような区間のカウントに使える。**単調増加・減少**な数に対して強い。連続部分列を得る際にも有効   
- しゃくとりは左端を全探索で決めて、右端を二分探索でもできがち   
- 半分全列挙：計算量減らすテクいやつ。ちょっと理解が浅いので要勉強   
- 二つのリストを比べるとき、片方sortしてそれに対して二分探索するといいかも   
- 区間を扱う問題はrについて昇順に見るとうまいこといくらしい(競プロフレンズさん談)   
## 連続部分列
- 多くの場合、尺取りだが左端固定の右端を二分探索でうまくいくことが多い   
- 文字列の場合、出現回数の累積和をとるとうれしいこともある   
## 座標圧縮   
- key := 圧縮前, value := 圧縮後としてdictで管理   
## 動的計画法   
- いくつか前の演算結果を利用する。**漸化式**のイメージ   
- DPの復元：ゴールから逆向きにスタートし、どの道のりできたかを調べる   
- 部分和：二次元のdpを行う。イメージは表計算。小さい和から順に作れるか見ていく   
- ナップサック：表計算。制約を見てiとjを何にするか決める   
- LCS：最長部分文字列。二次元DPを行う。それぞれの文字列のi,j文字目までを用いて作れる最長の部分文字列をdp[i][j]に格納する    
- 編集距離：LCSのような表を考えるが、一方の1~i+1文字目の文字列からもう一方の1~j+1文字目の文字列を作る際の編集距離をdp[i][j]に格納する   
- 区間DP：dp[左端][右端]でDP。上と違いマス目の表をイメージすると混乱するので注意。ちなみによくわかってない。要勉強   
- 遷移形式：一手先を考えてDP   
- bitDP：状態を二進数で管理。bit演算で遷移していく   
- LIS：長さkの部分列を作るときの**末尾の数の最小値**を管理して、二分探索を用いて貰うDPをする   
- ダブリング：1,2,4,8,..手先を前計算しておくことでn手先を答える。繰り返し二乗法のイメージでnを二進数に分解することでlognまで計算量が落ちる   
- ダブリングの味噌：dp[i + 1][j] = dp[i][dp[i][j]] <- マジでこれの説ある
- 配るDPを貰うDPと見て、貰える区間の最小値を貰えばセグ木で高速化できる   
- 状態遷移において**何に着目するか**には注意するべき(じゃんけんでは勝敗でなく出す手に着目するなど)
## 全探索   
### bit全探索   
- bitで状態を管理して全探索   
- n = 30くらいまでならいける  
### 順列・組み合わせ全探索   
- 順列全探索：n = 10くらいまでなら間に合う   
- `list(itertools.permutations(list))`で順列を全列挙したlistが得られる   
- `from more_itertools import distinct_permutations`で順列全探索で**重複を除いたもの**を高速に得るモジュールを使える   
- **listに変換するのはめちゃくちゃ遅い**ので、`for l in itertools.permutations(list):`でやると良い   
- 組み合わせ全探索：nCrで間に合いそうか判定
- `itertools.combinations(list(range(1,n+1)), m)`は[1, ..., n]から重複なしでm個選ぶ組み合わせを全列挙する   
- 自明ではあるが、得られる組み合わせは狭義単調増加   
- 樹形図全列挙：再帰や`itertools.product(list)`で実装できる。いわゆる直積・デカルト積？
## かっこ列典型
- スタックで管理。左から順にpushしていって、正しいかっこ列のときpopする。最後に空になればOK   
- "(" := +1, ")" := -1とすると累積和でmin(pre_sum) > 0 and pre_sum[-1] == 0 => OK   
- 言い換えると、あるiについて常に**iより左側の"("の数は")"の数以上**    
## 繰り返し二乗法   
- 指数を2進変換し、ビットが立っている箇所に関して累乗をかけあわせる   
- 掛け算したとき指数は足し算なのをイメージするとうまくいくことがわかりやすいかも   
- a**bを愚直に求めるとO(b)だが,O(logb)に減らせる   
- 前計算でも無理なくらい**大きい指数**の累乗に有効   