# 数学的知識
## 素数
- ある数nが素数であることは,math.isqrt(n)以下の素数でnが割り切れないことと同値   
- これを用いた判定よりさらに計算量を減らしたのがエラトステネスのふるい（B26参照）  
## 最小公約数・最大公倍数
- lcm * gcd == a * bが成り立つ   
- ユークリッドの互除法忘れがち   
## mod   
- a/bを素数mで割ったときの余りはa * (b**m-2)をmで割ったときの余りと等しい（フェルマーの小定理）   
- pythonはこの逆元をpow(a, b, m)で高速に求められる   
- ただ、上記のフェルマーの小定理はmが素数の時しか使えないので、素数でない場合は、パスカルの三角形だかなんだかをつかうらしい   
- modは引き算に言い換えられる。 ex: a mod b = a - (a//b)*b
## 関数   
- 二次方程式は解の公式を用いると誤差が怖いので二分探索でやる
- 二元n次方程式は片方固定   
- 式変形して上下から評価して全探索とか割とやりがち   
### 凸関数   
- グラフが下に凸のような関数。**凸関数同士の和の関数は凸関数**
- 三分探索か微分で解ける
## ゲーム   
- ゲームの勝ち方：ある手における**勝ち負けの状態についてDP**   
- ニム和：積まれた石の石取りゲームで有効。同じ高さの山のとき後手が先手の真似をすれば勝ち確なことを利用し、ゲームDPと同様に遷移を考えると、XOR = 0なら後手が勝ちを言える。(鉄則A33)   
- **後手が先手の真似で勝てるならNim和**でOK
- Grundy数：遷移できる状態のうち、それに含まれない最小の非負整数(Mex)。なので、操作を行えない状態のgrundy数は自明に0。non-zeroで勝ちの状態  
- 操作できるパターンプラス1しかGrundy数は存在しない。なぜなら、ある状態から遷移できる状態は多くとも操作できる種類個だから。さらに、**規則性**がある   
- ~~Nim和もGrundy数もABCで出るまで魔法として扱うこととする。すみません~~   
## 転倒数
- 本来あるべき正しい順序とは逆の順序で並んでいる要素のペアの総数   
- つまるところ、バブルソートのソート回数みたいなもん   
- ちなみにO(N**2)だが、BITで高速化ができる（要履修）   
