# グラフアルゴリズム
## 注意！
- グラフが与えられたからと言って以下のアルゴリズムに飛びつくと思考ロックされて解けなくなるかもしれない。   
- いったん落ち着いて愚直に解けないか考えてみましょう！
## 幅優先探索
- bfs：同じ深さの頂点に広げていく   
- 辺に重みがない最短経路絡みで有効。キューで実装   
- 01bfs：**辺の重みが二種のみ**であれば、**両端キュー**でbfsをすればダイクストラより高速に動作する   
- コストがかかる移動はappend, かからないならappendleft
## 深さ優先探索   
- dfs：行ける深さまで行って、再帰で戻って別の未達の頂点へ移動する   
- 深さの管理：頂点ごとに深さを持てば、未達かどうかの判定もできる   
- pathを管理するには**stuck**と相性がよさそう。再帰なので   
## UnionFind木
- グラフの操作や同じ連結成分にある頂点の組が含まれるかの判断、**連結成分の数え上げ**に強い
- 辺の削除は難しいので,逆に見て辺の追加と捉える
- 閉路の削除は,辺を受け取った時,その辺がつなぐ頂点がすでに同じグループかどうか見て,**同じならuniteしない**とすると消せる
- ある頂点の**部分木のサイズ**を知りたい -> **その頂点はuniteしなければ部分木が残る** 
## ダイクストラ法   
- **重み付きグラフ**で最短経路を求める際に有効
- 今いる頂点の近傍で未到達の頂点を探す -> コストを累積して未到達な頂点のときのコストを更新   
- つまり近い頂点に貪欲に移動する   
- bfsをpriority queueで実装して,コストに着目してpopするので,辺の情報は（コスト,頂点）の**タプル**で持つ
- pathを得たい場合は,DPと同様に**さかのぼって得る**
- **辺の重みが負であればバグる**らしく,その時はBellman-Ford法を用いるらしい
## Bellman-Ford法   
- いつか勉強して書く
## 最小全域木   
- 木の定義：n個の頂点と(n - 1)本の辺で連結された閉路を持たない無向グラフ   
- すべての頂点が連結である全域木の中で**辺の長さの合計が最も小さい**もの。クラスカル法で実装できる   
### クラスカル法
- 辺を重みが小さい方からUnionFind木で貪欲につないでいく。ただし、すでに同じ連結成分の時は木であるため、その時は連結しない   
## 最大フロー問題   
- 重み付き有向グラフで表されたパイプラインでスタートからゴールまで流せる水の総量を最大化する問題   
- 残余グラフ：残り容量を順方向に、使用済み容量を逆方向に張ったグラフ。これで流したフローを戻す操作を可能にする   
### 最小カット問題   
- 辺に削除コストが与えられたグラフで、スタートからゴールまでたどり着けないように辺を削除するときのコストの最小値を求める問題   
- 最大フロー最小カット定理から最大フロー問題と答えが同じであることが知られる   
### 燃やす埋める問題   
- 選択肢とそのコストが与えられ、選択肢同士に依存関係があるような問題   
1. 依存関係を有効辺と見てコストで重み付き有向グラフを貼り、最大フロー・最小カットを考えれば良い   
1. sから各頂点に選択肢1のコスト、各頂点からtに選択肢2のコスト、依存関係のある頂点aからbにinfで辺を張る   
1. 最小カットはコストの最小値であることに注意して答えを求める   
### 最大二部マッチング   
- ペアになっても良いものがいくつか与えられ、各頂点から張った辺を1つしか選べないとしたとき、最大いくつの希望を満たせるか   
- 条件はsから各頂点、各頂点からtに張る辺の容量で表せる
1. s -> i, i -> ペアになっても良いj, j -> tへ容量1で辺を張る   
1. sからtへフローを流し、最大フローが答え
### Ford-Fulkerson法   
- O(F * M)で最大フローを求める   
- **重みが負の辺がある際、正常に動作しない**
1. 残余グラフ上の容量0の辺を通らない頂点1からnまでのパスを見つける   
1. パスにおける容量の最小値をfとするとき、パス上に流量fだけ流す。逆方向の辺はf減らすことに注意   
1. 1でパスが見つからなくなるまで、1, 2を繰り返す   
## 謎の書置き   
- 有向グラフは辺を逆向きに見て、ある頂点からBFSすると、その頂点に到達可能な頂点がわかる。**逆に考える**はとても有効
- グラフが同型であることは,頂点が置き換えられていると捉えられる（？）
