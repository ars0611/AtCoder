# グラフアルゴリズム
## 注意！
- グラフが与えられたからと言って以下のアルゴリズムに飛びつくと思考ロックされて解けなくなるかもしれない。   
- いったん落ち着いて愚直に解けないか考えてみましょう！
## 幅優先探索
- bfs：同じ深さの頂点に広げていく   
- 辺に重みがない最短経路絡みで有効。キューで実装   
- 01bfs：**辺の重みが二種のみ**であれば、**両端キュー**でbfsをすればダイクストラより高速に動作する   
- コストがかかる移動はappend, かからないならappendleft
## 深さ優先探索   
- dfs：行ける深さまで行って、再帰で戻って別の未達の頂点へ移動する   
- 深さの管理：頂点ごとに深さを持てば、未達かどうかの判定もできる   
- pathを管理するには**stuck**と相性がよさそう。再帰なので   
## UnionFind木
- グラフの操作や同じ連結成分にある頂点の組が含まれるかの判断、**連結成分の数え上げ**に強い
- 辺の削除は難しいので,逆に見て辺の追加と捉える
- 閉路の削除は,辺を受け取った時,その辺がつなぐ頂点がすでに同じグループかどうか見て,**同じならuniteしない**とすると消せる
- ある頂点の**部分木のサイズ**を知りたい -> **その頂点はuniteしなければ部分木が残る** 
## ダイクストラ法   
- **重み付きグラフ**で最短経路を求める際に有効
- 今いる頂点の近傍で未到達の頂点を探す -> コストを累積して未到達な頂点のときのコストを更新   
- つまり近い頂点に貪欲に移動する   
- bfsをpriority queueで実装して,コストに着目してpopするので,辺の情報は（コスト,頂点）の**タプル**で持つ
- pathを得たい場合は,DPと同様に**さかのぼって得る**
- **辺の重みが負であればバグる**らしく,その時はBellman-Ford法を用いるらしい
## Bellman-Ford法   
- いつか勉強して書く
## 最小全域木   
- すべての頂点が連結である全域木の中で辺の長さの合計が最も小さいもの。クラスカル法で実装できる   
## クラスカル法
- 配列のソートとUnion-Findで貪欲的に短い辺からつないでいく   
## 謎の書置き   
- 有向グラフは辺を逆向きに見て、ある頂点からBFSすると、その頂点に到達可能な頂点がわかる。**逆に考える**はとても有効
- グラフが同型であることは,頂点が置き換えられていると捉えられる（？）
