今はただの殴り書きではあるが、もっと知識が増えたら体系的にまとめたい

---実装時に気を付ける基礎的なこと---
.join()はstr型にしか使えない
for文回すときはiのrangeケア
整数平方数が欲しければsqrtではなくisqrtを用いましょう(int(math.sqrt)は誤差がでる)
除算でオーバーフローの可能性があるなら、式変形をして整数で扱えるようにする
自明だが、桁数がとても大きい数の演算は計算に時間がかかるため油断するとTLE踏む
計算量の見積もりは雰囲気ではなく丁寧にやる
クエリを逆順に取得したら,出力も逆順にしましょう
配列が持つデータの型は一意に定めよう。boolとintを持つ配列とか使うとくそ遅い
テストケースは自分でも考えてみる。
while num < math.sqrt(tmp) とかするとループのたびにモジュール呼び出してTLEするのでwhileの前で変数につっこもう
配列の交換は計算量がでかすぎて非現実的。変数でどこにいったか管理してあげよう。

---データ型関連---
配列.pop(0)よりdeque.popleft()のほうが早い

heapq.heapify(list) :=listを優先度付きキューに変換
heapq.heappush(list, value) := listにvalueをpush
heapq.heappop(list) := heapからminをpop
逆に,maxをpopしたかったら符号反転して格納すればよい

sorted(list,key = lambda x:x[n])とすると二次元配列listを第n列に着目してsortできる
list_copy = copy.deepcopy(list)とすると深いコピーが作れる

set()：順序付き集合で重複を許さないし、参照時はO(1)

from sortedcontainers import SortedSet, SortedList, SortedDict
勝手にsortしてくれる上ににぶたんも備わっている最強データ構造
環境構築はbashで pip install sortedcontainersを実行するだけ

from more_itertools import distinct_permutations
順列全列挙で重複を除いてくれる -> set(itertools(s))を高速にやってくれる

defaultdict(int) は、存在しないキーにアクセスされたら0を自動でセットする辞書
変数名[key] = valueで追記
for value in dict_a.values(): 辞書型のvalueについてすべて参照できる。.keys()とするとkeyについても同様
list = sorted(dict.keys())とするとkeyを昇順にしたlistを得る。.values()とするとvalueについても同様

部分文字列を削除していくやつとかのテトリスみたいに連動して消す奴はスタックでうまくいきがち。

---アルゴリズム関連---
スライドmax,min：尺取りの感覚で累積max,minをとれる

かっこ列典型
スタックで管理。左から順にpushしていって、正しいかっこ列のときpopする。最後に空になればOK
"(" := +1, ")" := -1とすると累積和でmin(pre_sum) > 0 and pre_sum[-1] == 0 => OK
言い換えると、あるiについて常にiより左側の"("の数は")"の数以上 

二分探索：bisect.bisect_left(list,挿入したい値) = 挿入すべきidx
単調増加な関数->答えで二分探索 i.e. 答えがある値以上か以下かTF返すcheck関数
しゃくとり法：条件を満たすような区間のカウントに使える。単調増加・減少な数に対して強い
半分全列挙：計算量減らすテクいやつ
二つのリストを比べるとき、片方sortしてそれに対して二分探索するといいかも 
答えで二部探索：答えがmax/minｐっぽい -> 答えになりうる値で判定できる -> その値に対して単調性がある -> ほなやるか
ようかんパーティー要履修
区間を扱う問題はrについて昇順に見るとうまいこといくらしい

座標圧縮：dict{key:value}
key := 圧縮前, value := 圧縮後とする

動的計画法：いくつか前の演算結果を利用する
DPの復元：ゴールから逆向きにスタートし、どの道のりできたかを調べる
部分和：二次元のdpを行う。イメージは表計算。小さい和から順に作れるか見ていく。
ナップサック：表計算。制約を見てiとjを何にするか決める。
LCS：最長部分文字列。二次元DPを行う。それぞれのi,j文字目までを用いて作れる最長の部分文字列をdp[i][j]に格納する。
編集距離：LCSのような表を考えるが、一方の1~i+1文字目の文字列からもう一方の1~j+1文字目の文字列を作る際の編集距離をdp[i][j]に格納する。
区間DP：dp[左端][右端]でDP。上と違いマス目の表をイメージすると混乱するので注意。
遷移形式：一手先を考えてDP。
bitDP：状態を二進数で管理。bit演算で遷移していく
LIS：長さkの部分列を作るときの末尾の数の最小値を管理して、二分探索用いて貰うDPをする
ダブリング：1,2,4,8,..手先を前計算しておくことでn手先を答える
動的計画法、なんかセグ木で高速化できるらしい
状態遷移において何に着目するかには注意するべき(じゃんけんでは勝敗でなく出す手に着目するなど)

from itertools import combinations
combinations(list(range(1,n+1)), m)は[1, ..., n+1]から重複なしでn個選ぶ組み合わせを全列挙する
自明ではあるが、得られる組み合わせは狭義単調増加
list(itertools.permutations(list))で順列を全列挙したlistが得られる
listに変換するのはめちゃくちゃ遅いことが発覚した。for l in permutationsでやると良い
樹形図全列挙：再帰やitertools.productで実装できる(ABC367 C) <- これ直積ってやつだ

繰り返し二乗法：指数を進変換し、ビットが立っている箇所に関して累乗をかけあわせる
->a**bを愚直に求めるとO(b)だが,O(logb)に減らせる

セグ木：各セルに区間に関する情報を持つ。深くなるたびに扱う区間の長さが半分にされる

---数学的知識---
ある数nが素数であることは,math.isqrt(n)以下の素数でnが割り切れないことと同値
->これを用いた判定よりさらに計算量を減らしたのがエラトステネスのふるい（B26参照）

lcm * gcd == a * bが成り立つ

a/bを素数mで割ったときの余りはa * (b**m-2)をmで割ったときの余りと等しいらしい(証明略)
pythonはこの逆元をpow(a, b, m)で高速に求められるらしい。すごい。
modは引き算に言い換えられる。 ex: a mod b = a - (a//b)*b

二次方程式は解の公式を用いると誤差が怖いので二分探索でやる
二元n次方程式は片方固定。

ゲームの勝ち方：勝ち負けの状態についてDP
ニムの勝ち方：積まれた石の石取りゲーム。同じ高さの山のとき後手が先手の真似をすれば勝ち確なことを利用し、ゲームDPと同様に遷移を考えると、XOR = 0なら後手が勝ちを言える。(鉄則A33)
Grundy数：遷移できる状態のうち、それに含まれない最小の非負整数(Mex)。なので、操作を行えない状態のgrundy数は自明に0。non-zeroで勝ちの状態。
また、操作できるパターンプラス1しかGrundy数は存在しない。なぜなら、ある状態から遷移できる状態は多くとも操作できる種類個だから。また、規則性がある。
Nim和もGrundy数もABCで出るまで魔法として扱うこととする。

転倒数：本来あるべき正しい順序とは逆の順序で並んでいる要素のペアの総数
つまるところ、バブルソートのソート回数みたいなもん
ちなみにO(N**2)だが、BITで高速化ができる（要履修）

---考察面---
Cあるある：q個のqueryを受け取る。文章通り実装すると二重ループになってしまうので、操作などに着目して特徴的なものを変数こねくりまわしてどうにかすると良い。
query系の問題はデータの持ち方を工夫するとTLEが取れるかも
偶奇に着目するとよいことがあるかも
因数分解のような考え方を用いることで愚直にやった際の計算量からある程度改善されることがある
上限値を決める。困難は分割しよう!><
前から愚直に考えてうまくいかないときは,視点を変えて後ろから考えてみるとうまくいくかも
全探索をする際,何に対して全探索するか変えるとうまくいくかも
問題設定通りに素直に実装するのが難しい場合,言い換えを考えるとうまくいくかも
操作手順が自由かつどの手順でも同じ結果に帰着するなら,不変量に着目
制約からエスパーするのも一つの手段（例：n <= 8で十分小さいから順列全探索やbit全探索を疑うなど）

---グラフアルゴリズム---
グラフが与えられたからと言って以下のアルゴリズムに飛びつくと思考ロックされて解けなくなるかもしれない。
いったん落ち着いて愚直に解けないか考えてみましょう！

bfs：辺に重みがない最短経路絡みで有効
01bfs：辺の重みが二種のみであれば、両端キューでbfsをすればダイクストラより高速
具体的には、頂点それぞれに到達コストを持たせたうえで、到達コストより低いなら高いコストの時append、低いときappendleft

dfs：grid絡みであれば,dxとdyの配列用意して,nodeを定義せずにdx,dyを関数で使って探索していくとうまい
移動回数数えながらdfs：関数内でvisitedをリセットしたり出力用のansに++すると良いかも
pathを管理するにはstuckと相性がよさそう

Union-Find：グラフの操作や同じ連結成分にある頂点の組が含まれるかの判断、連結成分の数え上げに強い
辺の削除は難しいので,逆に見て辺の追加と捉える
閉路の削除は,辺を受け取った時,その辺がつなぐ頂点がすでに同じグループかどうか見て,同じならuniteしないとすると消せる
ある頂点の部分木のサイズを知りたい -> その頂点はuniteしなければ部分木が残る 

ダイクストラ法：重み付きグラフで最短経路を求める際に有効
今いる頂点の近傍で未到達の頂点を探す -> コストを累積して未到達な頂点のときのコストを更新
bfsをpriority queueで実装して,コストに着目してpopするので,辺の情報は(コスト,頂点)のタプルで持つ
pathを得たい場合は,DPと同様にさかのぼって得る
辺の重みが負であればバグるらしく,その時はBellman-Ford法を用いるらしい

最小全域木：すべての頂点が連結である全域木の中で辺の長さの合計が最も小さいもの。クラスカル法で実装できる
クラスカル法：配列のソートとUnion-Findで貪欲的に短い辺からつないでいく


有向グラフでも,無向グラフと見て順向きでない辺のほうの情報を持っておくとき,符号反転とかうまいことするといいかも
グラフが同型であることは,頂点が置き換えられていると捉えられる（？）

---その他---
bit演算 &(and),|(or),^(xor)はいちいち自分で二進変換せずともやってくれる
if y >> j & 1 == 1: #yを二進表記した際のjビット目が1かどうか判定し,1なら処理を実行
format(int,'b')：intを二進数に変換したものがstr型で返す
popcount：二進変換した際に立っているビットの数。->これに関する問題は周期を見るといいかも

文字列.strip()で改行や空白,tabなどの空白文字,または特定の文字列を削除できる。
s.isurrer() / .islower()で大文字 / 小文字判別しboolで返す。
s.upper() / .lower()で全文字大文字 / 小文字にする。
str型の"00123"に対して、int("00123")をするとint型の123になる <- 便利だなあ
min(s, t)で辞書順最小を返してくれるらしい、天才か？？

box.sort(key = lambda x:(x[0], -x[1]))で第一引数について昇順にした後、第一引数が等しいもの同士で第二引数について降順にしてくれる
lambdaはあくまで無名関数。cmp_to_keyを用いればsortする際の関数を詳細に決定できる。

set型について、和集合とか包含関係とか結構柔軟に集合に関する演算できるから実装したかったら調べてみよう!

a = [list(ai)[::-1] for ai in zip(*a)] で2次元配列を90度回転できる！