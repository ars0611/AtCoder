今はただの殴り書きではあるが、もっと知識が増えたら体系的にまとめたい

---実装時に気を付ける基礎的なこと---
.join()はstr型にしか使えない
for文回すときはiのrangeケア
整数平方数が欲しければsqrtではなくisqrtを用いましょう(int(math.sqrt)は誤差がでる)
除算でオーバーフローの可能性があるなら、式変形をして整数で扱えるようにする
計算量の見積もりは雰囲気ではなく丁寧にやる

---データ型関連---
配列.pop(0)よりdeque.popleft()のほうが早い

set()：順序付き集合で重複を許さないし、参照時はO(1)

defaultdict(int) は、存在しないキーにアクセスされたら0を自動でセットする辞書
変数名[key] = valueで追記
for value in dict_a.values(): 辞書型のvalueについてすべて参照できる。.keys()とするとkeyについても同様
list = sorted(dict.keys())とするとkeyを昇順にしたlistを得る。.values()とするとvalueについても同様

---アルゴリズム関連---
二分探索：bisect.bisect_left(list,挿入したい値) = 挿入すべきidx
単調増加な関数->答えで二分探索 i.e. 答えがある値以上か以下かTF返すcheck関数
しゃくとり法：条件を満たすような区間のカウントに使える
半分全列挙：計算量減らすテクいやつ
二つのリストを比べるとき、片方sortしてそれに対して二分探索するといいかも 

座標圧縮：dict{key:value}
key := 圧縮前, value := 圧縮後とする

動的計画法：いくつか前の演算結果を利用する
DPの復元：ゴールから逆向きにスタートし、どの道のりできたかを調べる
部分和：二次元のdpを行う。イメージは表計算
ナップサック：表計算。制約を見てiとjを何にするか決める。
LCS：最長部分文字列。二次元DPを行う。それぞれのi,j文字目までを用いて作れる最長の部分文字列をdp[i][j]に格納する。
編集距離：LCSのような表を考えるが、一方の1~i+1文字目の文字列からもう一方の1~j+1文字目の文字列を作る際の編集距離をdp[i][j]に格納する。
区間DP：dp[左端][右端]でDP。上と違いマス目の表をイメージすると混乱するので注意。
遷移形式：一手先を考えてDP。

---考察面---
Cあるある：q個のqueryを受け取る。文章通り実装すると二重ループになってしまうので、操作などに着目して特徴的なものを変数こねくりまわしてどうにかすると良い。

---その他---
bit演算 &(and),|(or),^(xor)はいちいち自分で二進変換せずともやってくれる
